import assert from 'assert';
import { BitImageRGBA, BPP_RGBA } from '../assets/images/bitImageRGBA';
import { AssetTextureRGBA } from '../assets/assetTextureRGBA';

// TEXTURES INDEX LAYOUT:

// FIRST INDEX:
// for each image:
//  num mipmaps (32bit)
//  ptr to first mipmap descriptor

// SECOND INDEX: (for each mipmap)
// width (32bit)
// height (32bit)
// ptr to mipmap image data (32bit)

// INDEX FIELDS SIZES
const NUM_MIPS_FIELD_SIZE = Uint32Array.BYTES_PER_ELEMENT;
const PTR_TO_FIRST_MIP_DESC_FIELD_SIZE = Uint32Array.BYTES_PER_ELEMENT;
const TEX_DESC_SIZE = NUM_MIPS_FIELD_SIZE + PTR_TO_FIRST_MIP_DESC_FIELD_SIZE;

const WIDTH_FIELD_SIZE = Uint32Array.BYTES_PER_ELEMENT;
const HEIGHT_FIELD_SIZE = Uint32Array.BYTES_PER_ELEMENT;
const OFFSET_TO_MIP_DATA_FIELD_SIZE = Uint32Array.BYTES_PER_ELEMENT;
const MIP_DESC_SIZE = WIDTH_FIELD_SIZE + HEIGHT_FIELD_SIZE + OFFSET_TO_MIP_DATA_FIELD_SIZE;

let texDescIndexSize: number; // first index level size

function calcWasmTexturesIndexSize(assetTextures: AssetTextureRGBA[]) {
  texDescIndexSize = assetTextures.length * TEX_DESC_SIZE;
  let size = texDescIndexSize;
  for (let i = 0; i < assetTextures.length; ++i) {
    const { Levels: levels } = assetTextures[i];
    size += levels.length * MIP_DESC_SIZE;
  }
  return size;
}

function copyTextures2WasmMem(
  textures: AssetTextureRGBA[],
  texturesIndex: Uint8Array,
  texturesPixels: Uint8Array,
) {
  assert(texDescIndexSize !== undefined);
  const { length: numTextures } = textures;
  const texsIndexView = new DataView(texturesIndex.buffer);
  let nextFirstMipDescAddr = texDescIndexSize;
  let nextMipPixelsAddr = 0;
  for (let i = 0; i < numTextures; ++i) {
    const texture = textures[i];
    const { Levels: levels } = texture;
    const numMips = levels.length;
    const nextTexDescAddr = i * TEX_DESC_SIZE;
    texsIndexView.setUint32(nextTexDescAddr, numMips, true);
    texsIndexView.setUint32(nextTexDescAddr + NUM_MIPS_FIELD_SIZE, nextFirstMipDescAddr, true);
    const mipDescView = new DataView(texturesIndex.buffer, nextFirstMipDescAddr);
    for (let j = 0; j < numMips; ++j) {
      const level = levels[j];
      const { Width: width, Height: height, Buf8: buf8 } = level;
      const mipDescStartOffset = j * MIP_DESC_SIZE;
      mipDescView.setUint32(mipDescStartOffset, width, true);
      mipDescView.setUint32(mipDescStartOffset + WIDTH_FIELD_SIZE, height, true);
      mipDescView.setUint32(mipDescStartOffset + WIDTH_FIELD_SIZE + HEIGHT_FIELD_SIZE, nextMipPixelsAddr, true);
      texturesPixels.set(buf8, nextMipPixelsAddr);
      nextMipPixelsAddr += buf8.length;
    }
    nextFirstMipDescAddr += numMips * MIP_DESC_SIZE;
  }
}

export { copyTextures2WasmMem, calcWasmTexturesIndexSize };
